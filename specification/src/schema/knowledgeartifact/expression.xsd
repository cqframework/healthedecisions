<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="urn:hl7-org:knowledgeartifact:r1" xmlns:dt="urn:hl7-org:cdsdt:r2" xmlns:sch="http://purl.oclc.org/dsdl/schematron" targetNamespace="urn:hl7-org:knowledgeartifact:r1" elementFormDefault="qualified">
	<xs:annotation>
		<xs:documentation>This file defines the core expression components used throughout knowledge artifacts. The core expression components defined here are intended to be general purpose, and beyond the datatypes in the cdsdt namespace, do not reference anything specific to the clinical decision support domain. This layering is intended to isolate the syntactic elements of a general purpose expression language from the more frequently varying elements of clinical decision support.</xs:documentation>
	</xs:annotation>
	<xs:complexType name="Expression" abstract="true">
		<xs:annotation>
			<xs:documentation>The Expression type defines the abstract base type for all expressions used in the HeDS expression language.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="description" type="xs:string" minOccurs="0" maxOccurs="1"/>
			<xs:element name="annotation" type="xs:anyType" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>The annotation element provides a mechanism for decorating expressions with application-specific information such as translation hints, visual designer information, or debug symbols.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UnaryExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>The UnaryExpression type defines the abstract base type for all expressions that take a single argument.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BinaryExpression">
		<xs:annotation>
			<xs:documentation>The BinaryExpression type defines the abstract base type for all expressions that take two arguments.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="2" maxOccurs="2"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TernaryExpression">
		<xs:annotation>
			<xs:documentation>The TernaryExpression type defines the abstract base type for all expressions that take three arguments.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="3" maxOccurs="3"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NaryExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>The NaryExpression type defines an abstract base class for an expression that takes any number of arguments, including zero.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExpressionDef">
		<xs:annotation>
			<xs:documentation>The ExpressionDef type defines an expression and an associated name that can be referenced by any expression in the artifact. The name must be unique within the artifact.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expression" type="Expression"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="ExpressionRef">
		<xs:annotation>
			<xs:documentation>The ExpressionRef type defines an expression that references a previously defined NamedExpression. The result of evaluating an ExpressionReference is the result of evaluating the referenced NamedExpression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="name" type="xs:string"/>
				<xs:attribute name="libraryName" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ParameterDef">
		<xs:annotation>
			<xs:documentation>The ParameterDef type defines a parameter that can be referenced by name anywhere within an expression. Parameters are defined at the artifact level, and may be provided as part of the payload for an evaluation request. If no parameter value is provided, the default element is used to provide the value for the parameter. If no parameter or default is provided, the parameter is defined to be null.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="default" type="Expression" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="parameterType" type="xs:QName"/>
	</xs:complexType>
	<xs:complexType name="ParameterRef">
		<xs:annotation>
			<xs:documentation>The ParameterRef expression allows the value of a parameter to be referenced as part of an expression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="name" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Literals -->
	<xs:complexType name="Literal">
		<xs:annotation>
			<xs:documentation>The Literal type defines a single scalar value. For example, the literal 5, the boolean value true or the string "antithrombotic".</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
				<xs:attribute name="value" type="xs:anySimpleType" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Complex literal is not included, the decision was made that this would introduce
	multiple different ways of accomplishing the same thing (namely with a ComplexLiteral, and with
	an ObjectExpression. Given that ObjectExpression is more powerful, it was selected as the preferred
	approach. Note that specific literals are included for the ISO data types. 

	UPDATE: Based on specific feedback from Zynx and others, it is proposed that the ComplexLiteral
	expression be reintroduced to allow static orderable content to be expressed without the need to
	build it up with an expression.
	-->
	<xs:complexType name="ComplexLiteral">
		<xs:annotation>
			<xs:documentation>The ComplexLiteral expression allows an xml literal of any type to be included in an expression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="value" type="xs:anyType" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PropertyExpression">
		<xs:annotation>
			<xs:documentation>The PropertyExpression type is used within the ObjectLiteral type to provide the value of a specific property within an object literal expression.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="value" type="Expression" minOccurs="1" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="ObjectExpression">
		<xs:annotation>
			<xs:documentation>The ObjectExpression type allows objects of any type to be built up as an expression. The objectType attribute specifies the type of the object being built, and the list of property elements specify the values for the properties of the object. Note that the value of a property may be any expression, including another ObjectExpression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="property" type="PropertyExpression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="objectType" type="xs:QName"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectDescriptor">
		<xs:annotation>
			<xs:documentation>The ObjectDescriptor type allows arbitrary object descriptors to be built, allowing for the creation of a value that has enough information to uniquely identify an object, but is not the object itself. Object descriptors are used as part of the update and remove action sentences to allow the object to be updated to be described without creating the object itself.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="property" type="PropertyExpression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="objectType" type="xs:QName"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectRedefine">
		<xs:annotation>
			<xs:documentation>The ObjectRedefine expression returns an object of the same type as the source argument, with the same values for each property, except the values of the properties listed in the property elements. For those properties, the values will be set based on the expressions in those elements. This operator allows an object to be "copied" with new values specified only for a given list of properties.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="property" type="PropertyExpression" minOccurs="1" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Interval selector -->
	<xs:complexType name="Interval">
		<xs:annotation>
			<xs:documentation>The Interval selector defines an interval value. An interval must be defined using a point type that supports comparison, as well as Successor and Predecessor operations, and Minimum and Maximum Value operations.
			
The beginning and ending of the interval may each be defined as open or closed. Following standard terminology usage in interval mathematics, an open interval is defined to exclude the specified point, whereas a closed interval includes the point. The default is closed, indicating an inclusive interval.

The begin and end elements are both optional. If the begin element is not specified, the beginning point of the resulting interval is null. If the end element is not specified, the ending point of the resulting interval is null.

The static type of the Begin argument determines the type of the interval, and the End argument must be of the same type.

If the beginning point of the interval is null and the beginning of the interval is open, the beginning boundary of the interval is interpreted as unknown, and computations involving the beginning boundary will result in null.

If the beginning point of the interval is null and the beginning of the interval is closed, the interval is interpreted to begin at the start of the range of the point type, and computations involving the beginning point will be performed with that interpretation.

If the ending point of the interval is null and the ending of the interval is open, the ending boundary of the interval is unknown, and computations involving the ending point will result in null. 

If the ending point of the interval is null and the ending of the interval is closed, the interval is interpreted to end at the end of the range of the point type, and computations involving the ending point will be performed with that interpretation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="begin" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="end" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="beginOpen" type="xs:boolean" use="optional" default="false"/>
				<xs:attribute name="endOpen" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Examples 

	<operand xsi:Type="Interval">
		<begin xsi:Type="Literal" valueType="xs:Date" value="2010-10-10"/>
		<end xsi:Type="Literal" valueType="xs:Date" value="2010-10-11"/>
	</operand>

	-->
	<xs:complexType name="List">
		<xs:annotation>
			<xs:documentation>The List selector returns a value of type List, whose elements are the result of evaluating the arguments to the List selector, in order. The static type of the first argument determines the type of the resulting list, and each subsequent argument must be of that same type.
			
If any argument is null, the resulting list will have null for that element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="element" type="Expression" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="key" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Logical Operators -->
	<xs:complexType name="And">
		<xs:annotation>
			<xs:documentation>The And operator returns the logical conjunction of its arguments. Note that this operator is defined as n-ary, allowing any number of arguments. The result of And with no arguments is defined to be false. The result of And with a single argument is defined to be the result of the argument. The result of and with two arguments is defined using 3-valued logic semantics. This means that if either argument is false, the result is false; if both arguments are true, the result is true; otherwise, the result is null. The result of more than two arguments is defined as successive invocations of And.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Or">
		<xs:annotation>
			<xs:documentation>The Or operator returns the logical disjunction of its arguments. Note that this operator is defined as n-ary, allowing any number of arguments. The result of Or with no arguments is defined to be true. The result of Or with a single argument is defined to be the result of the argument. The result of Or with two arguments is defined using 3-valued logic semantics. This means that if either argument is true, the result is true; if both arguments are false, the result is false; otherwise, the result is null. The result of more than two arguments is defined as successive invocations of Or.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Not">
		<xs:annotation>
			<xs:documentation>The Not operator returns the logical negation of its argument. If the argument is true, the result is false; if the argument is false, the result is true; otherwise, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Conditional">
		<xs:annotation>
			<xs:documentation>The Conditional operator evaluates a condition, and returns the then argument if condition evaluates to true; otherwise the result of the else argument is returned. The static type of the then argument determines the result type of the conditional, and the else argument must be of that same type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="condition" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="then" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="else" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Examples
	<condition xsi:Type="Conditional">
		<condition xsi:type="Equal">
			<operand xsi:type="Property" Path="Name"/>
			<operand xsi:type="Literal" valueType="xs:string" value="Test"/>
		</condition>
		<then xsi:type="Literal" valueType="xs:string" value="Name was Test"/>
		<else xsi:type="Literal" valueType="xs:string" value="Name was not Test"/>
	</condition>
	-->
	<xs:complexType name="CaseItem">
		<xs:sequence>
			<xs:element name="when" type="Expression" minOccurs="1" maxOccurs="1"/>
			<xs:element name="then" type="Expression" minOccurs="1" maxOccurs="1"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Case">
		<xs:annotation>
			<xs:documentation>The Case operator allows for multiple conditional expressions to be chained together in a single expression, rather than having to nest multiple Conditional operators. In addition, the comparand operand provides a variant on the case that allows a single value to be compared in each conditional.
			
If a comparand is not provided, the type of each when element of the caseItems within the Case is expected to be boolean. If a comparand is provided, the type of each when element of the caseItems within the Case is expected to be of the same type as the comparand. An else element must always be provided.

The static type of the then argument within the first caseItem determines the type of the result, and the then argument of each subsequent caseItem and the else argument must be of that same type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="comparand" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="caseItem" type="CaseItem" minOccurs="1" maxOccurs="unbounded"/>
					<xs:element name="else" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Nullological Operators -->
	<!-- NOTE: Maybe may be implemented as a null-test on a boolean-valued expression. I am reluctant to introduce an actual Maybe operator
	because SQL doesn't have a MAYBE operator. (At least, most dialects don't). In fact, even the long-hand described previously (null-test
	on a boolean-valued expression) cannot be translated into an SQL dialect that does not have a MAYBE operator.
	-->
	<xs:complexType name="Null">
		<xs:annotation>
			<xs:documentation>The Null operator returns a null, or missing information marker. To avoid the need to cast this result, the operator is defined to return a typed null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IsNull">
		<xs:annotation>
			<xs:documentation>The IsNull operator determines whether or not its argument evaluates to null. If the argument evaluates to null, the result is true; otherwise, the result is false.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IfNull">
		<xs:annotation>
			<xs:documentation>The IfNull operator replaces a null with the result of a given expression. If the first argument evaluates to null, returns the result of the second argument. Otherwise, returns the result of the first argument.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Coalesce">
		<xs:annotation>
			<xs:documentation>The Coalesce operator returns the first non-null result in a list of argument. If all arguments evaluate to null, the result is null. The static type of the first argument determines the type of the result, and all subsequent arguments must be of that same type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Type Operators -->
	<xs:complexType name="Is">
		<xs:annotation>
			<xs:documentation>The Is operator allows the type of a result to be tested. The language must support the ability to test against any type. If the run-time type of the argument is of the type being tested, the result of the operator is true; otherwise, the result is false.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="isType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="As">
		<xs:annotation>
			<xs:documentation>The As operator allows the result of an expression to be cast as a given target type. This allows expressions to be written that are statically typed against the expected run-time type of the argument. If the argument is not of the specified type, strict determines whether the result is null (the default), or an exception is thrown.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="asType" type="xs:QName" use="required"/>
				<xs:attribute name="strict" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Convert">
		<xs:annotation>
			<xs:documentation>The Convert operator converts a value to a specific type. The result of the operator is the value of the argument converted to the target type, if possible. Note that use of this operator may result in a run-time exception being thrown if there is no valid conversion from the actual value to the target type.

This operator supports conversion between String and each of Boolean, Integer, Real, and Timestamp, as well as conversion from Integer to Real.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression">
				<xs:attribute name="toType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Comparison Operators -->
	<xs:complexType name="Equal">
		<xs:annotation>
			<xs:documentation>The Equal operator returns true if the arguments are equal; and false 
				otherwise. Equality semantics are defined to be value-based.

For scalars this means that equality returns true if and only if the result of each argument evaluates to the same value.

For object types, this means that equality returns true if and only if the objects are of the same type, and the values for all properties are the same.

For list types, this means that equality returns true if and only if the lists contain elements of the same type, have the same number of elements, and for each element in the lists, in order, the elements are equal using the same semantics.

For interval types, equality returns true if and only if the intervals are over the same point type, and they have the same value for the beginning and ending points of the interval.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NotEqual">
		<xs:annotation>
			<xs:documentation>The NotEqual operator returns true if its arguments are not the same value.

The NotEqual operator is a shorthand for invocation of logical negation of the Equal operator.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Less">
		<xs:annotation>
			<xs:documentation>The Less operator returns true if the first argument is less than the second argument.
			
If either argument is null, the result is null.

The Less operator is defined for the Integer, Real, String, Timestamp, and PhysicalQuantity types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Greater">
		<xs:annotation>
			<xs:documentation>The Greater operator returns true if the first argument is greater than the second argument.

If either argument is null, the result is null.

The Greater operator is defined for the Integer, Real, String, Timestamp, and PhysicalQuantity types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LessOrEqual">
		<xs:annotation>
			<xs:documentation>The LessOrEqual operator returns true if the first argument is less than or equal to the second argument.

If either argument is null, the result is null.

The LessOrEqual operator is defined for the Integer, Real, String, Timestamp, and PhysicalQuantity types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GreaterOrEqual">
		<xs:annotation>
			<xs:documentation>The GreaterOrEqual operator returns true if the first argument is greater than or equal to the second argument.

If either argument is null, the result is null.

The GreaterOrEqual operator is defined for the Integer, Real, String, Timestamp, and PhysicalQuantity types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Arithmetic Operators -->
	<xs:complexType name="Add">
		<xs:annotation>
			<xs:documentation>The Add operator performs numeric addition of its arguments.
			
If either argument is null, the result is null.

The Add operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Subtract">
		<xs:annotation>
			<xs:documentation>The Subtract operator performs numeric subtraction of its arguments.

If either argument is null, the result is null.

The Subtract operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Multiply">
		<xs:annotation>
			<xs:documentation>The Multiply operator performs numeric multiplication of its arguments.

If either argument is null, the result is null.

The Multiply operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Divide">
		<xs:annotation>
			<xs:documentation>The Divide operator performs numeric division of its arguments. Note that the result of Divide is a decimal, even if its arguments are integers.

If either argument is null, the result is null.

The Divide operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TruncatedDivide">
		<xs:annotation>
			<xs:documentation>The TruncatedDivide operator performs integer division of its arguments.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Modulo">
		<xs:annotation>
			<xs:documentation>The Modulo operator computes the remainder of the division of its arguments.

If either argument is null, the result is null.

The Modulo operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Ceiling">
		<xs:annotation>
			<xs:documentation>The Ceiling operator returns the first integer greater than or equal to the argument. 

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Floor">
		<xs:annotation>
			<xs:documentation>The Floor operator returns the first integer less than or equal to the argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Truncate">
		<xs:annotation>
			<xs:documentation>The Truncate operator returns the integer component of its argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Abs">
		<xs:annotation>
			<xs:documentation>The Abs operator returns the absolute value of its argument.

If the argument is null, the result is null.

The Abs operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Negate">
		<xs:annotation>
			<xs:documentation>The Negate operator returns the negative of its argument.

If the argument is null, the result is null.

The Negate operator is defined for the Integer and Real types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Round">
		<xs:annotation>
			<xs:documentation>The Round operator returns the nearest integer to its argument. The semantics of round are defined as a traditional round, meaning that a decimal value of 0.5 or higher will round to 1.

If the argument is null, the result is null.

Precision determines the decimal place at which the rounding will occur. If precision is not specified or null, 0 is assumed.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="precision" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Ln">
		<xs:annotation>
			<xs:documentation>The Ln operator computes the natural logarithm of its argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Log">
		<xs:annotation>
			<xs:documentation>The Log operator computes the logarithm of its first argument, using the second argument as the base.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Power">
		<xs:annotation>
			<xs:documentation>The Power operator raises the first argument to the power given by the second argument.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Succ">
		<xs:annotation>
			<xs:documentation>The Succ operator returns the successor of the argument. For example, the successor of 1 is 2.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pred">
		<xs:annotation>
			<xs:documentation>The Pred operator returns the predecessor of the argument. For example, the predecessor of 2 is 1.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MinValue">
		<xs:annotation>
			<xs:documentation>The MinValue operator returns the minimum representable value for the given type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MaxValue">
		<xs:annotation>
			<xs:documentation>The MaxValue operator returns the maximum representable value for the given type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="valueType" type="xs:QName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- String Operators -->
	<xs:complexType name="Concat">
		<xs:annotation>
			<xs:documentation>The Concat operator performs string concatenation of its arguments.

If any argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Combine">
		<xs:annotation>
			<xs:documentation>The Combine operator combines a list of strings, optionally separating each string with the given separator.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="separator" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Split">
		<xs:annotation>
			<xs:documentation>The Split operator splits a string into a list of strings using a separator.

If the stringToSplit argument is null, the result is null.

If the stringToSplit argument does not contain any appearances of the separator, the result is a list of strings containing one element that is the value of the stringToSplit argument.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="stringToSplit" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="separator" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Length">
		<xs:annotation>
			<xs:documentation>The Length operator returns the length of its argument.
			
For strings, the length is the number of characters in the string.

For intervals, the length is defined as the successor of the ending point minus the beginning point.

If the argument is null, or either the beginning or ending point of the interval is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Upper">
		<xs:annotation>
			<xs:documentation>The Upper operator returns the upper case of its argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Lower">
		<xs:annotation>
			<xs:documentation>The Lower operator returns the lower case of its argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Indexer">
		<xs:annotation>
			<xs:documentation>The Indexer operator returns the indexth element in a string or list.
			
Indexes in strings and lists are defined to be 1-based.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="operand" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="index" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Pos">
		<xs:annotation>
			<xs:documentation>The Pos operator returns the 1-based index of the given pattern in the given string.
			
If the pattern is not found, the result is 0.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="pattern" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="string" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Substring">
		<xs:annotation>
			<xs:documentation>The Substring operator returns the string within stringToSub, beginning at the 1-based index startIndex, and consisting of length characters.
			
If length is ommitted, the substring returned starts at startIndex and continues to the end of stringToSub.

If stringToSub or startIndex is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="stringToSub" minOccurs="1" maxOccurs="1"/>
					<xs:element name="startIndex" minOccurs="1" maxOccurs="1"/>
					<xs:element name="length" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- TODO: Trimming, Padding, Replicating, Insert, IsDigit, IsLetter, IsWhitespace? 
	These operators are not primitive, but they are very useful shorthands. Do we want to leave them out for now? (CREF doesn't actually have any of these, and hasn't needed them so far...)
	-->
	<!-- Temporal Operators -->
	<xs:simpleType name="DateGranularity">
		<xs:annotation>
			<xs:documentation>The DateGranularity type specifies the granularities available for temporal operations such as DateAdd, DateDiff, and DatePart.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Year"/>
			<xs:enumeration value="Month"/>
			<xs:enumeration value="Week"/>
			<xs:enumeration value="Day"/>
			<xs:enumeration value="Hour"/>
			<xs:enumeration value="Minute"/>
			<xs:enumeration value="Second"/>
			<xs:enumeration value="Millisecond"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="DateAdd">
		<xs:annotation>
			<xs:documentation>The DateAdd operator adds numberOfPeriods date periods of the specified granularity to the given date.
			
Note that this is different than adding an Interval to a date time, because for operations on granularities such as month and year, the interval is not well-defined due to varying month and year lengths. As a result, DateAdd is used to provide well-defined and consistent semantics for date arithmetic involving months and years. 

If any argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="date" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="numberOfPeriods" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--Example
	<operand xsi:Type="DateAdd">
		<date xsi:Type="Property" path="BirthDate"/>
		<granularity xsi:Type="Value" valueType="DateGranularity" value="Month"/>
		<numberOfPeriods xsi:Type="Value" valueType="xs:int" value="-6"/>
	</operand>
	-->
	<xs:complexType name="DateDiff">
		<xs:annotation>
			<xs:documentation>The DateDiff operator returns the number of granularity boundaries occurring between startDate and endDate.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="startDate" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="endDate" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatePart">
		<xs:annotation>
			<xs:documentation>The DatePart operator returns the granularity component of the given date.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="date" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="granularity" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DateOf">
		<xs:annotation>
			<xs:documentation>The DateOf operator returns the date (with no time component) of the argument. 

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TimeOf">
		<xs:annotation>
			<xs:documentation>The TimeOf operator returns the time (with no date component) of the argument.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Today">
		<xs:annotation>
			<xs:documentation>The Today operator returns the date (with no time component) of the start timestamp associated with the evaluation request. See the Now operator for more information on the rationale for defining the Today operator in this way.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Now">
		<xs:annotation>
			<xs:documentation>Returns the date and time of the start timestamp associated with the evaluation request. Now is defined in this way for two reasons:
1) The operation will always return the same value within any given evaluation, ensuring that the result of an expression containing Now will always return the same result.

2) The operation will return the timestamp associated with the evaluation request, allowing the evaluation to be performed with the same timezone information as the data delivered with the evaluation request.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Date">
		<xs:annotation>
			<xs:documentation>The Date operator constructs a date/time value from the given components.
			
If any of year, month, or day is null, the result is null. The hour, minute, second, and millisecond may all be null, provided that no value appears in a granularity that is strictly smaller than a granularity that has already been provided. For example, hour may be non-null, and if minute, second, and millisceond are all null, they are assumed to be 0. However, if hour is null, minute, second, and millisecond must all be null as well.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="year" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="month" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="day" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="hour" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="minute" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="Expression" minOccurs="0" maxOccurs="1"/>
					<xs:element name="millisecond" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Interval Operators -->
	<!-- Equal (already defined) -->
	<!-- NotEqual (already defined) -->
	<!-- Length: Already defined in string operators -->
	<xs:complexType name="Begin">
		<xs:annotation>
			<xs:documentation>The Begin operator returns the starting point of an interval. 
			
If the beginning of the interval is open, this operator returns the Successor of the defined beginning point of the interval.

If the beginning of the interval is closed, this operator returns the defined beginning point of the interval if it is not null. 

Otherwise, it returns the minimum value of the point type of the interval.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
		<!-- Begin(i) = if not(i.beginOpen) then IfNull(i.begin, T.MinimumValue()) else Succ(i.begin) -->
	</xs:complexType>
	<xs:complexType name="End">
		<xs:annotation>
			<xs:documentation>The End operator returns the ending point of an interval.
			
If the ending of the interval is open, this operator returns the Predecessor of the defined ending point of the interval.

If the ending of the interval is closed, this operator returns the defined ending point of the interval if it is not null. 

Otherwise, it returns the maximum value of the point type of the interval.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
		<!-- End(i) = if not(i.endOpen) then IfNull(i.end, T.MaximumValue()) else Pred(i.end) -->
	</xs:complexType>
	<xs:complexType name="Contains">
		<xs:annotation>
			<xs:documentation>The Contains operator returns true if the first operand contains the second.
			
There are two overloads of this operator:
	List, T : The type of T must be the same as the element type of the list.
	Interval, T : The type of T must be the same as the point type of the interval.
	
For the List, T overload, this operator returns true if the given element is in the list.

For the Interval, T overload, this operator returns true if the given point is greater than or equal to the beginning point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is null, the result of the boundary comparison is considered true.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Contains(i, p) = (if not(i.beginOpen) then p >= IsNull(i.begin, p) else p > i.begin) and (if not(i.endOpen) then p <= IsNull(i.end, p) else p < i.end) -->
	</xs:complexType>
	<xs:complexType name="In">
		<xs:annotation>
			<xs:documentation>The In operator tests for membership in an interval or list.
			
There are two overloads of this operator:
	T, List : The type of T must be the same as the element type of the list.
	T, Interval : The type of T must be the same as the point type of the interval.
	
For the T, List overload, this operator returns true if the given element is in the given list.

For the T, Interval overload, this operator returns true if the given point is greater than or equal to the beginning point of the interval, and less than or equal to the ending point of the interval. For open interval boundaries, exclusive comparison operators are used. For closed interval boundaries, if the interval boundary is null, the result of the boundary comparison is considered true.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- In(p, i) = (if not(i.beginOpen) then p >= IsNull(i.begin, p) else p > i.begin) and (if not(i.endOpen) then p <= IsNull(i.end, p) else p < i.end) -->
	</xs:complexType>
	<xs:complexType name="Includes">
		<xs:annotation>
			<xs:documentation>The Includes operator returns true if the first operand completely includes the second.
			
There are two overloads of this operator:
	List, List : The element type of both lists must be the same.
	Interval, Interval : The point type of both intervals must be the same.

For the List, List overload, this operator returns true if the first operand includes every element of the second operand.

For the Interval, Interval overload, this operator returns true if beginning point of the first interval is less than or equal to the beginning point of the second interval, and the ending point of the first interval is greater than or equal to the ending point of the second interval.

This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Includes(i1, i2) = Begin(i1) <= Begin(i2) and End(i1) >= End(i2) -->
	</xs:complexType>
	<xs:complexType name="IncludedIn">
		<xs:annotation>
			<xs:documentation>The IncludedIn operator returns true if the first operand is completely included in the second.

There are two overloads of this operator:
	List, List : The element type of both lists must be the same.
	Interval, Interval : The point type of both intervals must be the same.
	
For the List, List overload, this operator returns true if every element in the first list is included in the second list.

For the Interval, Interval overload, this operator returns true if the beginning point of the first interval is greater than or equal to the beginning point of the second interval, and the ending point of the first interval is less than or equal to the ending point of the second interval.

This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- IncludedIn(i1, i2) = Begin(i1) >= Begin(i2) and End(i1) <= End(i2) -->
	</xs:complexType>
	<xs:complexType name="ProperIncludes">
		<xs:annotation>
			<xs:documentation>The ProperIncludes operator returns true if the first operand includes the second, and is strictly larger.
			
There are two overloads of this operator:
	List, List : The element type of both lists must be the same.
	Interval, Interval : The point type of both intervals must be the same.
	
For the List, List overload, this operator returns true if the first list includes every element of the second list, and first list is strictly larger.

For the Interval, Interval overload, this operator returns true if the first interval includes the second interval, and the intervals are not equal.

This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- ProperIncludes(i1, i2) = Includes(i1, i2) and i1 <> i2 -->
	</xs:complexType>
	<xs:complexType name="ProperIncludedIn">
		<xs:annotation>
			<xs:documentation>The ProperIncludedIn operator returns true if the first operand is included in the second, and is strictly smaller.
			
There are two overloads of this operator:
	List, List : The element type of both lists must be the same.
	Interval, Interval : The point type of both intervals must be the same.

For the List, List overload, this operator returns true if every element of the first list is included in the second list, and the first list is strictly smaller.

For the Interval, Interval overload, this operator returns true if the first interval is included in the second interval, and the intervals are not equal.

This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- ProperIncludedIn(i1, i2) = IncludedIn(i1, i2) and i1 <> i2 -->
	</xs:complexType>
	<xs:complexType name="Before">
		<xs:annotation>
			<xs:documentation>The Before operator returns true if the first interval ends before the second one starts. In other words, if the ending point of the first interval is less than the starting point of the second interval.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Before(i1, i2) = End(i1) < Begin(i2) -->
	</xs:complexType>
	<xs:complexType name="After">
		<xs:annotation>
			<xs:documentation>The After operator returns true if the first interval starts after the second one ends. In other words, if the starting point of the first interval is greater than the ending point of the second interval.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- After(i1, i2) = Begin(i1) > End(i2) -->
	</xs:complexType>
	<xs:complexType name="Meets">
		<xs:annotation>
			<xs:documentation>The Meets operator returns true if the first interval ends immediately before the second interval starts, or if the first interval starts immediately after the second interval ends. In other words, if the ending point of the first interval is equal to the predecessor of the starting point of the second, or if the starting point of the first interval is equal to the successor of the ending point of the second.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Meets(i1, i2) = End(i1) = Begin(i2) -->
	</xs:complexType>
	<xs:complexType name="Overlaps">
		<xs:annotation>
			<xs:documentation>The Overlaps operator returns true if the first interval overlaps the second. In other words, if the ending point of the first interval is greater than or equal to the starting point of the second interval, and the starting point of the first interval is less than or equal to the ending point of the second interval.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Overlaps(i1, i2) = End(i1) >= Begin(i2) and Begin(i1) <= End(i2) -->
	</xs:complexType>
	<xs:complexType name="OverlapsBefore">
		<xs:annotation>
			<xs:documentation>The OverlapsBefore operator returns true if the first interval starts before and overlaps the second. In other words, if the first interval contains the starting point of the second interval.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- OverlapsBefore(i1, i2) = Contains(i1, Begin(i2)) -->
	</xs:complexType>
	<xs:complexType name="OverlapsAfter">
		<xs:annotation>
			<xs:documentation>The OverlapsAfter operator returns true if the first interval overlaps and ends after the second. In other words, if the starting point of the first interval contains the ending point of the second interval.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- OverlapsAfter(i1, i2) = Contains(i1, End(i2)) -->
	</xs:complexType>
	<xs:complexType name="Begins">
		<xs:annotation>
			<xs:documentation>The Begins operator returns true if the first interval begins the second. In other words, if the starting point of the first is equal to the starting point of the second interval and the ending point of the first interval is less than or equal to the ending point of the second interval.

This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Begins(i1, i2) = Begin(i1) = Begin(i2) and End(i1) <= End(i2) -->
	</xs:complexType>
	<xs:complexType name="Ends">
		<xs:annotation>
			<xs:documentation>The Ends operator returns true if the first interval ends the second. In other words, if the starting point of the first interval is greater than or equal to the starting point of the second, and the ending point of the first interval is equal to the ending point of the second.
			
This operator uses the semantics described in the Begin and End operators to determine interval boundaries.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
		<!-- Ends(i1, i2) = Begin(i1) >= Begin(i2) and End(i1) = End(i2) -->
	</xs:complexType>
	<xs:complexType name="Collapse">
		<xs:annotation>
			<xs:documentation>The Collapse operator returns the unique set of intervals that completely covers the ranges present in the given list of intervals.

If the list of intervals is empty, the result is empty. If the list of intervals contains a single interval, the result is a list with that interval. If the list of intervals contains nulls, they will be excluded from the resulting list.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Union">
		<xs:annotation>
			<xs:documentation>The Union operator returns the union of the operands.
			
This operator has two overloads:
	List
	Interval

For the list overload, this operator returns a list with all elements from all operands.

For the interval overload, this operator returns the interval that starts at the earliest starting point in the arguments, and ends at the latest starting point in the arguments. If the arguments do not overlap, this operator returns null. 

If any of the arguments are null, the result is null.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Intersect">
		<xs:annotation>
			<xs:documentation>The Intersect operator returns the intersection of the operands. 
			
This operator has two overloads:
	List
	Interval

For the list overload, this operator returns a list with the elements that appear in all the lists.

For the interval overload, this operator returns the interval that defines the overlapping portion of the arguments. If the arguments do not overlap, this operator returns null.

If any of the arguments are null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Difference">
		<xs:annotation>
			<xs:documentation>The Difference operator returns the difference of the two arguments.
			
This operator has two overloads:
	List, List
	Interval, Interval

For the list overload, this operator returns a list with the elements that appear in the first operand, that do not appear in the second operand.

For the interval overload, this operator returns the portion of the first interval that does not overlap with the second. If the arguments do not overlap, or if the second argument is properly contained within the first, this operator returns null.

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BinaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- List/Set Operators -->
	<xs:complexType name="IsEmpty">
		<xs:annotation>
			<xs:documentation>The IsEmpty operator returns true if the list contains no elements. 
			
If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IsNotEmpty">
		<xs:annotation>
			<xs:documentation>The IsNotEmpty operator returns true if the list contains any elements.

If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Union (already defined) -->
	<!-- Intersect (already defined) -->
	<!-- Difference (already defined) -->
	<xs:complexType name="Filter">
		<xs:annotation>
			<xs:documentation>The Filter operator returns a list with only those elements in the source list for which the condition element evaluates to true.
			
If the source argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="condition" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Equal (already defined) -->
	<!-- NotEqual (already defined) -->
	<xs:complexType name="First">
		<xs:annotation>
			<xs:documentation>Returns the first element in a list. If the order by attribute is specified, the list is sorted by that ordering prior to returning the first element.
			
If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Last">
		<xs:annotation>
			<xs:documentation>The Last operator returns the last element in a list. If the order by attribute is specified, the list is sorted by that ordering prior to returning the last element.
			
If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Indexer (already defined) -->
	<xs:complexType name="IndexOf">
		<xs:annotation>
			<xs:documentation>The IndexOf operator returns the 1-based index of the given element in the given source list. 

If either argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Contains (already defined) -->
	<!-- In (already defined) -->
	<!-- Includes (alread defined) -->
	<!-- IncludedIn (already defined) -->
	<!-- ProperIncludes (already defined) -->
	<!-- ProperIncludedIn (already defined) -->
	<xs:complexType name="Expand">
		<xs:annotation>
			<xs:documentation>The Expand operator flattens a list of lists into a single list.
			
If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UnaryExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Sort">
		<xs:annotation>
			<xs:documentation>The Sort operator returns a list with all the elements in source, sorted by the given orderBy.
			
If the argument is null, the result is null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
				<xs:attribute name="orderBy" type="xs:string" use="optional"/>
			</xs:extension>
			<!-- TODO: Model ordering more explicitly? Multi-column sort? Ascending/Descending? -->
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ForEach">
		<xs:annotation>
			<xs:documentation>The ForEach expression iterates over the list of elements in the source element, and returns a list with the same number of elements, where each element in the new list is the result of evaluating the element expression for each element in the source list.
			
If the source argument is null, the result is null.

If the element argument evaluates to null for some item in the source list, the resulting list will contain a null for that element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
					<xs:element name="element" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Distinct">
		<xs:annotation>
			<xs:documentation>The Distinct operator takes a list of elements and returns a list containing only the unique elements within the input. For example, given the list of integers { 1, 1, 1, 2, 2, 3, 4, 4 }, the result of Distinct would be { 1, 2, 3, 4 }.
			
The operator uses equality comparison semantics as defined in the Equal operator.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Current">
		<xs:annotation>
			<xs:documentation>The Current expression returns the value of the object currently in scope. For example, within a ForEach expression, this returns the current element being considered in the iteration.
			
It is an error to invoke the Current operator outside the context of a scoped operation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Aggregate Operators -->
	<!-- TODO: Support grouping? -->
	<xs:complexType name="AggregateExpression" abstract="true">
		<xs:annotation>
			<xs:documentation>Aggregate expressions perform operations on lists of data, either directly on a list of scalars, or indirectly on a list of objects, with a reference to a property present on each object in the list.
			
Aggregate expressions deal with missing information by excluding missing values from consideration before performing the aggregated operation. For example, in a Sum over Dose, any instance of Medication with no value for Dose would be ignored.

An aggregate operation performed over an empty list is defined to return null, except as noted in the documentation for each operator (Count, AllTrue, and AnyTrue are the exceptions).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="1" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="path" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Count">
		<xs:annotation>
			<xs:documentation>The Count operator returns the number of non-null elements in the source.
			
If a path is specified, the count returns the number of elements that have a value for the property specified by the path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Sum">
		<xs:annotation>
			<xs:documentation>The Sum operator returns the sum of non-null elements in the source.
			
If a path is specified, elements with no value for the property specified by the path are ignored. 

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Min">
		<xs:annotation>
			<xs:documentation>The Min operator returns the minimum element in the source. 
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Max">
		<xs:annotation>
			<xs:documentation>The Max operator returns the maximum element in the source.

If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Avg">
		<xs:annotation>
			<xs:documentation>The Avg operator returns the average of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.
			
If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Median">
		<xs:annotation>
			<xs:documentation>The Median operator returns the median of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Mode">
		<xs:annotation>
			<xs:documentation>The Mode operator returns the statistical mode of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Variance">
		<xs:annotation>
			<xs:documentation>The Variance operator returns the statistical variance of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationVariance">
		<xs:annotation>
			<xs:documentation>The PopulationVariance operator returns the statistical population variance of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StdDev">
		<xs:annotation>
			<xs:documentation>The StdDev operator returns the statistical standard deviation of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationStdDev">
		<xs:annotation>
			<xs:documentation>The PopulationStdDev operator returns the statistical standard deviation of the elements in source.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, null is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AllTrue">
		<xs:annotation>
			<xs:documentation>The AllTrue operator returns true if all the elements in source are true.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, true is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AnyTrue">
		<xs:annotation>
			<xs:documentation>The AnyTrue operator returns true if any element in source is true.
			
If a path is specified, elements with no value for the property specified by the path are ignored.

If source contains no non-null elements, false is returned.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="AggregateExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- Data Operators -->
	<xs:complexType name="Property">
		<xs:annotation>
			<xs:documentation>The Property operator returns the value of the property on source specified by the path attribute.
			
If the path attribute contains qualifiers, each qualifier is traversed to obtain the actual value.

If a scope is specified, the name is used to resolve the scope in which the path will be resolved. Scopes can be named by operators such as Filter and ForEach.

Property expressions can also be used to access the individual points and open indicators for interval types using the property names begin, end, beginOpen, and endOpen.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Expression">
				<xs:sequence>
					<xs:element name="source" type="Expression" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="path" type="xs:string" use="required"/>
				<xs:attribute name="scope" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>
